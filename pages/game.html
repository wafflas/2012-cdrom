<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Game</title>
  <link rel="stylesheet" href="../styles.css" />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    .game-container {
      width: 400px;
      height: 450px;
      margin: 20px auto;
      display: none;
      box-shadow: 0 0 30px rgba(0, 229, 255, 0.3);
      border-radius: 5px;
      background-color: #020a0d;
      /* Ensure no scaling or aspect ratio changes */
      position: relative;
      overflow: visible;
    }
    canvas {
      display: block;
      width: 400px;
      height: 450px;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    .album-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .game-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
    }
    /* Remove responsive scaling to prevent map access issues */
    @media (max-width: 480px) {
      .minidisc-layout {
        overflow-x: auto;
        max-width: 100%;
      }
      .game-container {
        transform: none;
        width: 400px;
        height: 450px;
      }
    }
  </style>
</head>
<body>
  <!-- Background Video - Same as index.html -->
  <div class="fullscreen-video">
    <video id="background-video" autoplay muted loop>
      <source src="../media/audio/background.mp4" type="video/mp4" />
    </video>
  </div>
  
  <!-- Background Music - Same as index.html, needed for continuity -->
  <audio id="bg-music" loop preload="auto">
    <source src="../media/audio/twelvee pavlou mela [music].mp3" type="audio/mp3" />
  </audio>

  <!-- Content from existing game.html -->
  <div class="minidisc-layout">
    <div class="album-content">
      <h2 class="album-header">GAME</h2>
      
      <div id="game-menu" style="margin-top: 40px; letter-spacing: 1px; text-align: center;">
        <p style="opacity: 0.7; margin-bottom: 20px;">INSERT COIN</p>
        <div style="display: inline-block; position: relative;">
          <span class="interactive-text" id="start-game" style="position: relative; display: inline-block; font-size: 18px; cursor: pointer;">START</span>
        </div>
      </div>
      
      <!-- Pacman Game Container - Integrated directly into the layout -->
      <div class="game-section">
        <div class="game-container" id="pacman-container">
          <canvas id="canvas" width="400" height="450" tabindex="1"></canvas>
          <div style="display:none;">
            <img id="animation" src="pacman/animations.gif" width="140" height="20">
            <img id="ghosts" src="pacman/canvas.png" width="352" height="242">
          </div>
        </div>
        
        <!-- Back to menu button - Only shown when game is active -->
        <div id="back-to-menu" style="margin-top: 15px; display: none;">
          <span class="interactive-text" style="cursor: pointer; font-size: 14px;">BACK TO MENU</span>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Back button -->
  <a href="javascript:void(0)" onclick="navigateWithTransition('../index.html')" class="back-button">X</a>
  
  <!-- Common elements -->
  <div class="copyright">Â© 2025 cd 2012</div>
  <div class="scanlines"></div>
  
  <!-- Page-specific script -->
  <script>
    // Add global key handler for Pacman
    window.keyPressed = function(keyCode) {
      // Map arrow keys to Pacman directions
      switch(keyCode) {
        case 37: // Left arrow
          if (window.pacman) {
            window.pacman.nextDirection = 2; // DIRECTION_LEFT
          }
          break;
        case 38: // Up arrow
          if (window.pacman) {
            window.pacman.nextDirection = 3; // DIRECTION_UP
          }
          break;
        case 39: // Right arrow
          if (window.pacman) {
            window.pacman.nextDirection = 4; // DIRECTION_RIGHT
          }
          break;
        case 40: // Down arrow
          if (window.pacman) {
            window.pacman.nextDirection = 1; // DIRECTION_BOTTOM
          }
          break;
      }
    };
    
    // Expose function to reset game
    window.resetGame = function() {
      if (window.restartPacmanAndGhosts) {
        window.restartPacmanAndGhosts();
        window.score = 0;
        window.lives = 3;
      }
    };
    
    // Expose function to pause game
    window.pauseGame = function() {
      // Nothing specific to do here, as the game is controlled by the visibility
    };
    
    // Play background video
    document.addEventListener('DOMContentLoaded', () => {
      const backgroundVideo = document.getElementById('background-video');
      const bgMusic = document.getElementById('bg-music');
      const startGameBtn = document.getElementById('start-game');
      const gameContainer = document.getElementById('pacman-container');
      const gameMenu = document.getElementById('game-menu');
      const backToMenuBtn = document.getElementById('back-to-menu');
      
      backgroundVideo.play().catch(error => {
        console.log('Background video autoplay failed:', error);
      });
      
      // Handle background music continuity
      if (bgMusic) {
        // Check if we have a stored position to resume from
        const musicPosition = parseFloat(sessionStorage.getItem('musicPosition'));
        const musicWasPlaying = sessionStorage.getItem('musicPlaying') === 'true';
        
        if (!isNaN(musicPosition) && musicWasPlaying) {
          bgMusic.currentTime = musicPosition;
          bgMusic.play().catch(error => {
            console.log('Background music autoplay failed:', error);
          });
        }
        
        // Store current time when navigating away
        window.addEventListener('beforeunload', () => {
          sessionStorage.setItem('musicPosition', bgMusic.currentTime);
          sessionStorage.setItem('musicPlaying', !bgMusic.paused);
        });
        
        // Keep the current time updated
        bgMusic.addEventListener('timeupdate', () => {
          if (!bgMusic.paused) {
            sessionStorage.setItem('musicPosition', bgMusic.currentTime);
          }
        });
      }
      
      // Add event listener for the START button
      startGameBtn.addEventListener('click', () => {
        // Hide menu and show game
        gameMenu.style.display = 'none';
        gameContainer.style.display = 'block';
        backToMenuBtn.style.display = 'block';
        
        // Load Pacman game scripts if they haven't been loaded yet
        if (!window.pacmanScriptsLoaded) {
          loadPacmanScripts();
        } else {
          // If already loaded, reset/restart the game
          if (window.resetGame && typeof window.resetGame === 'function') {
            window.resetGame();
          }
        }
        
        // Give the game canvas focus to ensure keyboard controls work
        const canvas = document.getElementById('canvas');
        setTimeout(() => {
          canvas.focus();
        }, 100);
      });
      
      // Add event listener for back to menu button
      backToMenuBtn.addEventListener('click', () => {
        gameContainer.style.display = 'none';
        backToMenuBtn.style.display = 'none';
        gameMenu.style.display = 'block';
        
        // Pause the game if a pause function exists
        if (window.pauseGame && typeof window.pauseGame === 'function') {
          window.pauseGame();
        }
      });
      
      // Function to load Pacman game scripts dynamically
      function loadPacmanScripts() {
        window.pacmanScriptsLoaded = true;
        
        const scripts = [
          'pacman/ghost.js',
          'pacman/pacman.js',
          'pacman/game.js'
        ];
        
        // Load scripts in sequence
        let loadedCount = 0;
        scripts.forEach(src => {
          const script = document.createElement('script');
          script.src = src;
          script.onload = () => {
            loadedCount++;
            if (loadedCount === scripts.length) {
              console.log('All Pacman scripts loaded');
              // Fix keyboard focus issues
              fixKeyboardControls();
            }
          };
          document.body.appendChild(script);
        });
      }
      
      // Function to fix keyboard controls
      function fixKeyboardControls() {
        // Add global keyboard listener to ensure movement works
        window.addEventListener('keydown', function(e) {
          // Prevent default browser scrolling on arrow keys
          if([37, 38, 39, 40].indexOf(e.keyCode) > -1) {
            e.preventDefault();
          }
          
          // If a keyPressed function exists in the game, forward the key event
          if (window.keyPressed && typeof window.keyPressed === 'function') {
            window.keyPressed(e.keyCode);
          }
        });
        
        // Fix canvas rendering to ensure full map is visible
        const canvas = document.getElementById('canvas');
        // Ensure canvas is using exact dimensions
        canvas.style.width = '400px';
        canvas.style.height = '450px';
        canvas.width = 400;
        canvas.height = 450;
        
        // Make canvas focusable
        canvas.setAttribute('tabindex', '1');
        canvas.style.outline = 'none'; // Remove focus outline
        
        // Add focus to canvas when clicked
        canvas.addEventListener('click', function() {
          this.focus();
        });
        
        // Ensure the canvas keeps focus
        setInterval(() => {
          if (gameContainer.style.display !== 'none' && document.activeElement !== canvas) {
            canvas.focus();
          }
        }, 1000);
        
        // Fix Pacman's collision detection and movement
        setTimeout(() => {
          if (window.Pacman) {
            // Adjust collision detection for better path navigation
            const originalCheckCollisions = Pacman.prototype.checkCollisions;
            Pacman.prototype.checkCollisions = function() {
              // Use a smaller hitbox for collision detection (more forgiving)
              const collisionPadding = 0.2; // Reduce collision box by 20%
              
              try {
                let isCollided = false;
                const mapX = parseInt((this.x - xOffset) / oneBlockSize);
                const mapY = parseInt((this.y - yOffset) / oneBlockSize);
                const mapXNext = parseInt((this.x - xOffset + oneBlockSize * (1 - collisionPadding)) / oneBlockSize);
                const mapYNext = parseInt((this.y - yOffset + oneBlockSize * (1 - collisionPadding)) / oneBlockSize);
                
                // Check only the corners that matter based on direction
                if (this.direction === DIRECTION_RIGHT) {
                  isCollided = map[mapY][mapXNext] === 1 || map[mapYNext][mapXNext] === 1;
                } else if (this.direction === DIRECTION_LEFT) {
                  isCollided = map[mapY][mapX] === 1 || map[mapYNext][mapX] === 1;
                } else if (this.direction === DIRECTION_UP) {
                  isCollided = map[mapY][mapX] === 1 || map[mapY][mapXNext] === 1;
                } else if (this.direction === DIRECTION_BOTTOM) {
                  isCollided = map[mapYNext][mapX] === 1 || map[mapYNext][mapXNext] === 1;
                }
                
                return isCollided;
              } catch (e) {
                // Fall back to original method if error occurs
                return originalCheckCollisions.call(this);
              }
            };
            
            // Make direction changes more responsive
            const originalChangeDirectionIfPossible = Pacman.prototype.changeDirectionIfPossible;
            Pacman.prototype.changeDirectionIfPossible = function() {
              // If we're close to center of a tile, make turning more likely to succeed
              const centerX = Math.floor((this.x - xOffset) / oneBlockSize) * oneBlockSize + oneBlockSize / 2 + xOffset;
              const centerY = Math.floor((this.y - yOffset) / oneBlockSize) * oneBlockSize + oneBlockSize / 2 + yOffset;
              const distanceFromCenterX = Math.abs(this.x - centerX + oneBlockSize / 2);
              const distanceFromCenterY = Math.abs(this.y - centerY + oneBlockSize / 2);
              
              // If near center of tile, temporarily increase speed to snap to grid
              const isNearCenterX = distanceFromCenterX < oneBlockSize * 0.3;
              const isNearCenterY = distanceFromCenterY < oneBlockSize * 0.3;
              
              if ((isNearCenterX || isNearCenterY) && this.direction !== this.nextDirection) {
                const tempSpeed = this.speed;
                if (isNearCenterX && (this.nextDirection === DIRECTION_UP || this.nextDirection === DIRECTION_BOTTOM)) {
                  this.x = centerX - oneBlockSize / 2;
                }
                if (isNearCenterY && (this.nextDirection === DIRECTION_LEFT || this.nextDirection === DIRECTION_RIGHT)) {
                  this.y = centerY - oneBlockSize / 2;
                }
                
                // Call original with potential position adjustments
                const result = originalChangeDirectionIfPossible.call(this);
                this.speed = tempSpeed;
                return result;
              }
              
              return originalChangeDirectionIfPossible.call(this);
            };
            
            console.log('Pacman movement and collision fixes applied');
          }
        }, 500); // Apply fixes after game has fully loaded
      }
      
      // Initialize glitch text effect
      initGlitchTextEffect();
    });
    
    // Navigation with loading transition
    function navigateWithTransition(url) {
      // Create loading animation
      const loadingEl = document.createElement('div');
      loadingEl.className = 'enigmatic-loading';
      
      // Create glitch container
      const glitchContainer = document.createElement('div');
      glitchContainer.className = 'glitch-container';
      
      // Add preview image with glitch effect
      const previewImg = document.createElement('img');
      previewImg.src = '../media/minidisc-2012nobg2.png';
      previewImg.className = 'preview-image';
      glitchContainer.appendChild(previewImg);
      
      // Add glitchy loading text
      const loadingText = document.createElement('div');
      loadingText.className = 'glitch-text';
      loadingText.textContent = 'Loading...';
      glitchContainer.appendChild(loadingText);
      
      // Add glitch container to loading element
      loadingEl.appendChild(glitchContainer);
      document.body.appendChild(loadingEl);
      
      // Navigate after delay
      setTimeout(() => {
        window.location.href = url;
      }, 1500);
    }
    
    /**
     * GlitchText Effect
     * Converts React component to vanilla JavaScript for hover effects
     * Applies a scrambled text animation when hovering over interactive elements
     */
    function initGlitchTextEffect() {
      const interactiveElements = document.querySelectorAll('.back-button, .interactive-text');
      const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      
      interactiveElements.forEach(item => {
        const originalText = item.textContent;
        let interval = null;
        let iterations = 0;
        
        // Store original text 
        item.dataset.originalText = originalText;
        
        item.addEventListener('mouseenter', () => {
          clearInterval(interval);
          iterations = 0;
          
          // Start the glitch effect on hover
          interval = setInterval(() => {
            item.textContent = originalText.split('')
              .map((char, index) => {
                // Return original character if it's already been displayed
                if (index < iterations) {
                  return originalText[index];
                }
                // Return random character for remaining positions
                return letters[Math.floor(Math.random() * 36)];
              })
              .join('');
            
            // Increase iterations faster for hover effect
            iterations += 1/6;
            
            // Stop when all characters are restored
            if (iterations >= originalText.length) {
              clearInterval(interval);
              item.textContent = originalText;
            }
          }, 25);
        });
        
        item.addEventListener('mouseleave', () => {
          // Reset immediately on leave
          clearInterval(interval);
          item.textContent = originalText;
        });
      });
    }
  </script>
</body>
</html> 